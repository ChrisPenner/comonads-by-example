{-# LANGUAGE TypeApplications #-}
module Comonads.Traced.AOC where

import qualified Data.Map as M
import Data.Maybe
import Comonads.Traced
import Control.Comonad
import Data.Set.Ordered as S

deps :: [(Char, Char)]
deps =
    [ ('G', 'M')
    , ('T', 'E')
    , ('P', 'M')
    , ('V', 'L')
    , ('Y', 'B')
    , ('K', 'Z')
    , ('H', 'I')
    , ('D', 'U')
    , ('C', 'L')
    , ('R', 'Z')
    , ('U', 'B')
    , ('J', 'M')
    , ('M', 'E')
    , ('I', 'X')
    , ('N', 'O')
    , ('S', 'F')
    , ('X', 'A')
    , ('F', 'Q')
    , ('B', 'Z')
    , ('Q', 'W')
    , ('L', 'W')
    , ('O', 'Z')
    , ('A', 'Z')
    , ('E', 'W')
    , ('W', 'Z')
    , ('G', 'R')
    , ('H', 'A')
    , ('A', 'W')
    , ('Y', 'D')
    , ('O', 'A')
    , ('V', 'U')
    , ('H', 'W')
    , ('K', 'F')
    , ('J', 'X')
    , ('V', 'R')
    , ('Q', 'A')
    , ('F', 'B')
    , ('G', 'P')
    , ('L', 'A')
    , ('B', 'Q')
    , ('H', 'J')
    , ('J', 'L')
    , ('F', 'E')
    , ('U', 'A')
    , ('G', 'Q')
    , ('G', 'S')
    , ('K', 'J')
    , ('N', 'B')
    , ('F', 'O')
    , ('C', 'Z')
    , ('B', 'E')
    , ('M', 'S')
    , ('A', 'E')
    , ('E', 'Z')
    , ('K', 'I')
    , ('P', 'A')
    , ('Y', 'L')
    , ('Y', 'J')
    , ('G', 'N')
    , ('Q', 'L')
    , ('D', 'X')
    , ('C', 'I')
    , ('K', 'B')
    , ('N', 'F')
    , ('D', 'M')
    , ('B', 'A')
    , ('U', 'J')
    , ('Q', 'Z')
    , ('X', 'F')
    , ('K', 'X')
    , ('U', 'E')
    , ('X', 'W')
    , ('K', 'Q')
    , ('I', 'E')
    , ('D', 'J')
    , ('P', 'I')
    , ('K', 'D')
    , ('S', 'X')
    , ('C', 'R')
    , ('P', 'W')
    , ('I', 'O')
    , ('S', 'O')
    , ('K', 'C')
    , ('N', 'Q')
    , ('L', 'E')
    , ('L', 'Z')
    , ('K', 'W')
    , ('Y', 'A')
    , ('L', 'O')
    , ('N', 'W')
    , ('R', 'W')
    , ('C', 'O')
    , ('H', 'X')
    , ('V', 'Y')
    , ('S', 'W')
    , ('V', 'E')
    , ('Q', 'E')
    , ('P', 'H')
    , ('V', 'H')
    , ('N', 'Z')
    , ('C', 'A')
    ]

dep' :: Char -> String
dep' c = fromMaybe "" $ M.lookup c mapping
  where
    mapping = M.unionsWith (<>) $ inject <$> deps
    inject (a, b) = M.singleton a [b]

t :: Traced (OSet Char) (OSet Char)
t = traced (unbiased . foldMap (Bias @L . S.fromList . dep'))
